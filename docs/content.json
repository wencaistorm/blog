{"meta":{"title":"前端码农的自留地","subtitle":"一起学习弯道超车的技术！","description":null,"author":"wencaizhang","url":"http://wencaizhang.com/blog"},"pages":[{"title":"关于我自己","date":"2017-06-03T10:13:19.000Z","updated":"2018-01-13T04:54:14.168Z","comments":false,"path":"about/index.html","permalink":"http://wencaizhang.com/blog/about/index.html","excerpt":"","text":"关于我此处应有自拍： 关于编程大学临毕业开始接触编程（请忽略诸如 c/c++ 之类的课程。。。），深深感觉到人类智慧的无穷，并为自己的渺小感到羞愧。。。 正在努力学习中 业余爱好喜欢写代码，尤其是键盘上面啪啪啪的感觉。。。 喜欢说英语，比如经常说：too young, too naive! 喜欢古文，比如我就念了一句诗：窈窕淑女，君子好逑。。。 最后求基友！"},{"title":"","date":"2018-01-09T10:36:52.237Z","updated":"2018-01-09T10:36:52.237Z","comments":false,"path":"categories/index.html","permalink":"http://wencaizhang.com/blog/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-01-09T10:36:52.239Z","updated":"2018-01-09T10:36:52.239Z","comments":false,"path":"tags/index.html","permalink":"http://wencaizhang.com/blog/tags/index.html","excerpt":"","text":""},{"title":"毒鸡汤","date":"2018-01-09T10:36:52.238Z","updated":"2018-01-09T10:36:52.238Z","comments":false,"path":"soul/index.html","permalink":"http://wencaizhang.com/blog/soul/index.html","excerpt":"","text":"body { } .page-content { border-bottom: none; } #main { background-image: url(http://www.syg315.com/images/dbg.jpg) } 终于明白，有些路，只能一个人走。那些邀约好同行的人，一起相伴雨季，走过年华，但有一天终究会在某个渡口离散。红尘陌上，独自行走，绿萝拂过衣襟，青云打湿诺言。山和水可以两两相忘，日与月可以毫无瓜葛。那时候，只一个人的浮世清欢，一个人的细水长流。 ——林徽因 于千万人之中遇见你所要遇见的人，于千万年之中，时间的无涯的荒野里，没有早一步，也没有晚一步，刚巧赶上了，那也没有别的话可说，惟有轻轻地问一声：“噢，你也在这里吗？” ——张爱玲 也许每一个男子全都有过这样的两个女人，至少两个。娶了红玫瑰，久而久之，红的变了墙上的一抹蚊子血，白的还是“床前明月光”娶了白玫瑰，白的便是衣服上的一粒饭粘子，红的却是心口上的一颗朱砂痣。 ——张爱玲 以前我认为那句话很重要，因为我相信有些事说出来就是一生一世。现在想想，说不说也没有什么分别。有些事情是会变的，我一直以为自己赢了，直到有一天我看着镜子才知道我输了。在我最美好的时间里，我最喜欢的人不在我身边，如果能重新开始该有多好 ——《东邪西毒》 生存还是毁灭，这是一个永恒的选择题。以至于到最后，我们成为一个什么样的人，可能不在于我们的能力，而且在于我们的选择。选择无处不在：面朝大海，春暖花开，是海子的选择；人不是生来被打败的，是海明威的选择；人固有一死，或重于泰山，或轻于鸿毛，是司马迁的选择。选择是一次又一次自我重塑的过程，让我们不断地成长，不断地完善。如果说，人生是一次不断选择的旅程，那么当千帆阅尽，最终留下的就是一片属于自己的独一无二的风景。 ——《朗读者》"}],"posts":[{"title":"数组方法小盘点","slug":"functions-about-array","date":"2018-01-14T05:08:14.000Z","updated":"2018-01-14T07:14:06.782Z","comments":true,"path":"2018/01/14/functions-about-array/","link":"","permalink":"http://wencaizhang.com/blog/2018/01/14/functions-about-array/","excerpt":"","text":"Array.prototype.slice()// slice 词典翻译为：切片。这里大致可以理解为从数组上“切下来”一部分，或”提取“一部分 描述： array.slice(start, end) 影响范围：不修改原数组，会返回一个新建的数组 返回值：返回一个浅复制了原数组中的元素的一个新数组，即如果元素为引用类型（对象），此对象发生改变，则新数组和原数组中的这个元素也会发生改变 第一个参数（start）： 从 start 指定的索引处开始“切片” 如果 start 为负数，表示从原数组倒数第几个元素开始 如果 start 省略，则从索引 0 开始 第二个参数（end）： 在 end 指定的索引处结束“切片”（但不包含该元素） 如果 end 为负数，表示从原数组倒数第几个元素结束 如果 end 被省略，则 slice 会一直提取到原数组末尾 如果 end 大于数组长度，slice 也会一直提取到原数组末尾 通过 slice 将类数组转化为数组 使用示例：demo1：提取原数组中第二个元素开始直到（不包含）第四个元素的所有元素（索引为 1，2 的元素）12345var arr = [ 1, 2, 3, 4 ];var sliced = arr.slice(1, 3);console.log(arr); // [ 1, 2, 3, 4 ]console.log(sliced); // [ 2, 3 ] demo2：省略第二个参数 end ，提取原数组中第二个参数开始到（包含）末尾的所有元素（索引为 1，2，3 的元素）12345var arr = [ 1, 2, 3, 4 ];var sliced = arr.slice(1);console.log(arr); // [ 1, 2, 3, 4 ]console.log(sliced); // [ 2, 3, 4 ] demo3：两个参数都省略，提取原数组所有元素12345var arr = [ 1, 2, 3, 4 ];var sliced = arr.slice();console.log(arr); // [ 1, 2, 3, 4 ]console.log(sliced); // [ 1, 2, 3, 4 ] demo4：转为类数组(arguments)为数组123456function list() &#123; var args = [].slice.call(arguments) console.log(args); // [ 1, 2, 3]&#125;var list1 = list(1, 2, 3);","categories":[],"tags":[{"name":"-javascript -array","slug":"javascript-array","permalink":"http://wencaizhang.com/blog/tags/javascript-array/"}]},{"title":"GitHub Pages","slug":"GitHub-Pages","date":"2018-01-09T10:30:53.000Z","updated":"2018-01-13T04:54:14.166Z","comments":true,"path":"2018/01/09/GitHub-Pages/","link":"","permalink":"http://wencaizhang.com/blog/2018/01/09/GitHub-Pages/","excerpt":"","text":"What is GitHub Pages 什么是 Github Pages？ Github Pages 是 Github 的静态页面托管服务。它设计的初衷是为了用户能够直接通过 Github 仓库来托管用户个人、组织或是项目的专属页面。参考：What is GitHub Pages? 友情提示：使用此功能需要对 git 及 GitHub 有一定了解 使用步骤： 注册 GitHub 账户 创建一个仓库 打开此仓库的 Settings 页签 找到 GitHub Pag 部分 因为 GitHub Pages 会展示指定位置（分支）的 index.html 或者 README.md，因此 Source 用于指定分支。 Source 字段有 4 个选项： 默认为 None ，即不显示 master branch，本仓库的 master 分支 master branch/docs folder，本仓库的 master 分支下的 docs 目录 gh-pages branch，本仓库的 gh-pages 分支（需创建后才显示此选项） 也就是说，只要把静态站点放到上面三个位置（分支）之一，然后设置正确的 Source 字段，即可使用 GitHub Pages 功能。生成的静态网站地址会友好的显示在 Source 字段上方。 GitHub Pages 使用思路扩展 很多开源项目都会选择将 master branch/docs 用于展示项目使用文档 制作个人兴趣静态网站（如：http://wencaizhang.com/demo) 作为个人静态博客站点（如：http://wencaizhang.com/blog)","categories":[{"name":"部署","slug":"部署","permalink":"http://wencaizhang.com/blog/categories/部署/"}],"tags":[{"name":"部署","slug":"部署","permalink":"http://wencaizhang.com/blog/tags/部署/"}]},{"title":"hexo 备份","slug":"hexo-admin","date":"2018-01-07T15:01:00.000Z","updated":"2018-01-09T10:36:52.265Z","comments":true,"path":"2018/01/07/hexo-admin/","link":"","permalink":"http://wencaizhang.com/blog/2018/01/07/hexo-admin/","excerpt":"","text":"关于备份源文件我是这么做的 在搭建博客的时候，通常都会在 GitHub 上面创建一个 git 仓库，利用 GitHub 提供的 gh-pages 功能，将 hexo 生成的静态网页提交到 master 分支。那么顺着这个思路，利用 git 的分支功能将这个仓库变成集展示和备份于一体的 git 仓库。 例如，创建 source 分支用于管理配置文件和博客文章源文件，如果对博客主题进行了自定义，还可以再创建一个 theme 分支用于管理主题。 这样做的好处，一方面是备份，另一个方面是方便在不同的电脑上快速搭建环境，只需要 git clone 和 npm install 两个命令就可以搞定！ 一键部署如果按照上面的方法做，每次写完文章最后都会用这么几个步骤： hexo 的部署命令 hexo d 提交 source 分支源文件 如果修改了主题，还要切换目录并提交 theme 分支 利用 npm scripts 可以一条命令全部搞定！ 做前端开发的同学可能会对此比较熟悉，在网站根目录下有一个 package.json 文件，里面有个 scripts 字段，这里面可以自定义命令。 如果对 npm scripts 不太了解的，推荐：npm scripts 使用指南 简单介绍下这段 npm scripts ： scripts 字段是一个对象。它的每一个属性，对应一段脚本。例如 dev 字段对应的脚本是 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s，命令行中使用 npm run dev 就可以执行这段脚本 &amp;&amp;: 表示前一个任务执行成功，后一个任务才执行，&amp; 则是两个任务同时执行 npm run dev: 主要用于本地预览博客，按照顺序执行 hexo clean、hexo g、hexo s，只有前一个任务执行成功，后一个才执行 npm run push: 部署博客 npm run prepush: 提交 source 分支 npm run postpush: 提交 theme 分支 钩子: npm scripts 有 pre 和 post 两个钩子。例如 push 脚本的钩子是 prepush 和 postpush，prepush 在 push 脚本之前执行，postpush 在 push 脚本之后执行。也就是说，执行 npm run push 的时候，会自动按照顺序先后执行 npm run prepush &amp;&amp; npm run push &amp;&amp; npm run postpush 。 因此，在部署时，只需执行命令 npm run push，会自动部署博客网站，提交 source 和 theme 分支。 123456\"scripts\": &#123; \"dev\": \"hexo clean &amp;&amp; hexo g &amp;&amp; hexo s\", \"prepush\": \"git add -A &amp;&amp; git commit -m update &amp;&amp; git push origin source\", \"push\": \"hexo clean &amp;&amp; hexo g &amp;&amp; hexo d\", \"postpush\": \"cd themes/indigo &amp;&amp; git add -A &amp;&amp; git commit -m update &amp;&amp; git push origin theme\"&#125;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://wencaizhang.com/blog/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://wencaizhang.com/blog/tags/hexo/"}]},{"title":"Git 分支","slug":"git/git-branch","date":"2018-01-06T07:43:23.000Z","updated":"2018-01-09T10:36:52.262Z","comments":true,"path":"2018/01/06/git/git-branch/","link":"","permalink":"http://wencaizhang.com/blog/2018/01/06/git/git-branch/","excerpt":"","text":"前言查看分支 git branch 查看本地分支 12$ git branch* master 美元符号 $ 是命令提示符，即后面语句为执行的命令 星号 * 表示当前分支为 master git branch -r 查看远程分支 123$ git branch -r origin/HEAD -&gt; origin/master origin/master origin 是默认的远程仓库的名字，origin/master 表示远程仓库的 master 分支 origin/HEAD 就像一个指针，表示默认分支，此处指向 origin/master，即 origin/master 是默认分支。 git branch -a 查看所有分支，包含本地分支和远程分支 1234$ git branch -a* master remotes/origin/HEAD -&gt; origin/master remotes/origin/master 当前分支为 master remotes 表示远程主机，远程主机可能不止一个，因此要指定远程主机的名字，origin 为远程主机的名字 创建分支 git branch &lt;分支名字&gt; 用于创建分支，默认以 HEAD（通常是 master 分支）作为起点来创建分支 12345$ git branch dev$ git branch dev* master git branch 命令仅仅建立了一个新分支，但不会自动切换到这个分支中去，因此当前分支仍是 master 切换分支 git checkout &lt;分支名字&gt; 用于切换分支 123456$ git checkout devSwitched to branch 'dev'$ git branch* dev master 切换分支之后，会有提示信息：Switched to branch &#39;dev&#39; 通过 git branch 命令查看，当前分支已经切换到 dev 创建并自动切换到新分支 git checkout -b &lt;分支名字&gt; 通过增加 -b 参数会创建分支并且切换到此分支： 1234567$ git checkout -b featureSwitched to a new branch 'feature'$ git branch dev* feature master 切换分支之后，会有提示信息：Switched to a new branch &#39;feature&#39;&#39; 通过 git branch 命令查看，当前分支已经切换到 feature 将本地分支推送到远程 git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 1234$ git push origin feature:featureTotal 0 (delta 0), reused 0 (delta 0)To https://github.com/wencaistorm/git-learn.git * [new branch] feature -&gt; feature 提示信息：* [new branch] feature -&gt; feature ，说明 push 成功！ 通过 git branch -a 命令验证，发现远程分支 origin/feature 已经被创建成功1234567$ git branch -a dev* feature master remotes/origin/HEAD -&gt; origin/master remotes/origin/feature remotes/origin/master git push &lt;远程主机名&gt; &lt;本地分支名&gt; 如果忽略远程分支名，则表示将本地分支推送到与本地分支存在追踪关系的远程分支，如果该远程分支不存在，则会被新建。 1234$ git push origin devTotal 0 (delta 0), reused 0 (delta 0)To https://github.com/wencaistorm/git-learn.git * [new branch] dev -&gt; dev 同样的提示：* [new branch] dev -&gt; dev 同样再来次验证，发现远程分支 origin/dev 已经被创建成功！12345678$ git branch -a* dev feature master remotes/origin/HEAD -&gt; origin/master remotes/origin/dev remotes/origin/feature remotes/origin/master 合并分支 git merge &lt;分支名字&gt; 用于合并分支（将指定分支合并到当前分支）例如在 dev 分支创建了一个 test.md 文件，就可以使用此命令把 dev 合并到 master 上（需提前切换到 master 分支） 123456$ git merge devUpdating 75dd5ff..f21cc70Fast-forward test.md | 1 + 1 file changed, 1 insertion(+) create mode 100644 test.md 最后别忘了，提交 master 分支 1234$ git push origin masterTotal 0 (delta 0), reused 0 (delta 0)To https://github.com/wencaistorm/git-learn.git 75dd5ff..f21cc70 master -&gt; master 删除本地分支 git branch -d &lt;本地分支名&gt; 删除本地分支，但只能删除已经被 merge 的分支。 123$ git branch -d deverror: The branch 'dev' is not fully merged.If you are sure you want to delete it, run 'git branch -D dev'. 删除失败，git 提示：dev 分支没有被合并，如果要强行删除，需要使用命令 git branch -D dev 需要注意的是，这里的合并，并不一定是合并到 master 分支，合并到任何分支都可以 git branch -D &lt;本地分支名&gt; 强行删除本地分支，即使此分支没有被 merge 12$ git branch -D devDeleted branch dev (was 4a332d3). 删除成功！ 删除远程分支 git push origin :&lt;远程分支名&gt; 将一个空分支推送到远程分支，也就意味着将删除这个远程分支 123$ git push origin :devTo https://github.com/wencaistorm/git-learn.git - [deleted] dev 删除成功，并且给出提示信息：- [deleted] dev 通过 git branch -a 命令验证，发现远程分支 origin/dev 已经被删除1234567$ git branch -a* dev feature master remotes/origin/HEAD -&gt; origin/master remotes/origin/feature remotes/origin/master git push origin --delete &lt;远程分支名&gt; 通过 --delete 或者 -d 参数删除远程分支 123$ git push origin --delete featureTo https://github.com/wencaistorm/git-learn.git - [deleted] feature 删除成功，同样给出提示信息：- [deleted] feature 通过 git branch -a 命令验证，发现远程分支 origin/feature 已经被删除123456$ git branch -a* dev feature master remotes/origin/HEAD -&gt; origin/master remotes/origin/master 重命名分支 分支情况如下：123$ git branch master* new 现在想把 new 分支重命名为 newer 分支，可以通过 git branch -m &lt;重命名前分支名称&gt; &lt;重命名后分支名称&gt;1$ git branch -m new newer 修改成功，重新查看分支123$ git branch master* newer 总结最后总结一下，因为 &lt;远程主机名&gt; 通常默认为 origin ，因此这里直接以 origin 表示 &lt;远程主机名&gt;： 查看分支 git branch 查看本地分支 git branch -r 查看远程分支 git branch -a 查看所有分支 创建和切换分支 git branch &lt;分支名字&gt; 创建分支 git checkout &lt;分支名字&gt; 切换分支 git checkout -b &lt;分支名字&gt; 创建并自动切换到新分支 把本地分支推送到远程 git push origin &lt;本地分支名&gt;:&lt;远程分支名&gt; （冒号两侧没有空格） git push origin &lt;本地分支名&gt; 合并分支 git merge &lt;分支名字&gt; 删除本地分支（注意-d 和 -D 的区别） git branch -d &lt;本地分支名&gt; 删除本地分支，但只能删除已经被 merge 的分支。 git branch -D &lt;本地分支名&gt; 强行删除本地分支，即使此分支没有被 merge 删除远程分支 git push origin :&lt;远程分支名&gt; （冒号左侧有两个空格） git push origin --delete &lt;远程分支名&gt; 或 git push origin -D &lt;远程分支名&gt; （--delete 和 -D 作用相同） 重命名分支 git branch -m &lt;重命名前分支名称&gt; &lt;重命名后分支名称&gt;","categories":[{"name":"Git","slug":"Git","permalink":"http://wencaizhang.com/blog/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://wencaizhang.com/blog/tags/Git/"}]},{"title":"正则表达式","slug":"regexp","date":"2018-01-02T08:27:53.000Z","updated":"2018-01-09T10:36:52.270Z","comments":true,"path":"2018/01/02/regexp/","link":"","permalink":"http://wencaizhang.com/blog/2018/01/02/regexp/","excerpt":"","text":"元字符元字符既可以是放在 [] 中的任意单个字符（如 [a] 表示匹配单个小写字符 a ） 也可以是字符序列（如 [a-d] 表示匹配 a 、 b 、 c 、 d 之间的任意一个字符，而 \\w 表示任意英文字母和数字及下划线） 下面是一些常见的元字符： 元字符 含义 . 匹配除 \\n 以外的任何字符（注意元字符是小数点）。 [abcde] 匹配 abcde 之中的任意一个字符 [a-h] 匹配 a 到 h 之间的任意一个字符 [^fgh] 不与 fgh 之中的任意一个字符匹配 \\w 匹配大小写英文字符及数字 0 到 9 之间的任意一个及下划线，相当于 [a-zA-Z0-9_] \\W 不匹配大小写英文字符及数字 0 到 9 之间的任意一个，相当于 [^a-zA-Z0-9_] \\s 匹配任何空白字符，相当于 [ \\f\\n\\r\\t\\v] \\S 匹配任何非空白字符，相当于 [^\\s] \\d 匹配任何 0 到 9 之间的单个数字，相当于 [0-9] \\D 不匹配任何 0 到 9 之间的单个数字，相当于 [^0-9] [\\u4e00-\\u9fa5] 匹配任意单个汉字（这里用的是 Unicode 编码表示汉字的 ) 正则表达式限定符上面的元字符都是针对单个字符匹配的，要想同时匹配多个字符的话，还需要借助限定符。 下面是一些常见的限定符 ( 下表中 n 和 m 都是表示整数，并且 0 &lt; n &lt; m) ： 限定符 含义 * 匹配 0 到多个元字符，相当于 {0,} ? 匹配 0 到 1 个元字符，相当于 {0,1} + 匹配至少 1 个元字符，相当于 {1,} {n} 匹配 n 个元字符 {n,} 匹配至少 n 个元字符 {n,m} 匹配 n 到 m 个元字符 \\b 匹配单词边界 ^ 字符串必须以指定的字符开始 $ 字符串必须以指定的字符结束 其他 由于在正则表达式中\\、?、*、^、$、+、(、)、|、{、[等字符已经具有一定特殊意义，如果需要用它们的原始意义，则应该对它进行转义，例如希望在字符串中至少有一个“ \\ ”，那么正则表达式应该这么写： \\+ 。 可以将多个元字符或者原义文本字符用括号括起来形成一个分组，比如 ^(13)[4-9]\\d{8}$ 表示任意以 13 开头的移动手机号码。 另外对于中文字符的匹配是采用其对应的 Unicode 编码来匹配的，对于单个 Unicode 字符，如 \\u4e00 表示汉字“一”， \\u9fa5 表示汉字“龥”，在 Unicode 编码中这分别是所能表示的汉字的第一个和最后一个的 Unicode 编码，在 Unicode 编码中能表示 20901 个汉字。 关于 \\b 的用法，它代表单词的开始或者结尾，以字符串 123a 345b 456 789d 作为示例字符串，如果正则表达式是 \\b\\d{3}\\b，则仅能匹配 456 。 可以使用 | 来表示或的关系，例如 [z|j|q] 表示匹配 z 、 j 、 q 之中的任意一个字母。 正则验证工具： https://regexper.com/ 正则对象属性 属性均为只读，无法设置其值 属性 含义 默认值 global 是否全文搜索 false ignoreCase 是否大小写敏感 false multiline 多行搜索 false lastIndex 是当前表达式匹配内容的最后一个字符的下一个位置 无 source 正则表达式的文本字符串 无 如下： 123456789101112var reg1 = /\\w/;var reg2 = /\\w/gim;console.log(reg1.global); // falseconsole.log(reg1.ignoreCase); // falseconsole.log(reg1.multiline); // falseconsole.log(reg1.source); // \"\\w\"console.log(reg2.global); // trueconsole.log(reg2.ignoreCase); // trueconsole.log(reg2.multiline); // trueconsole.log(reg2.source); // \"\\w\" 正则对象方法RegExp.prototype.test(str) 用于测试字符串参数中是否存在匹配正则表达式模式的字符串 如果存在则返回 true，否则返回 false 牛刀小试： 12345var reg = /\\w/;reg.test('a'); // truereg.test('ab'); // truereg.test('$'); // true 加上 g 标志后，结果有了一丝不同~~ 12345678var reg = /\\w/g;reg.test('ab'); // truereg.test('ab'); // truereg.test('ab'); // falsereg.test('ab'); // truereg.test('ab'); // truereg.test('ab'); // truereg.test('ab'); // false 这是因为在匹配的时候并不是每次都是从头开始的，而是每次匹配都会从上次匹配结果的下一个位置开始匹配，也就是 lastIndex 属性 第一次匹配到 a， 第二次从 b 开始，匹配到 b 第三次从 b 开始，没有匹配结果 因此出现上面的现象 12345var reg = /\\w/g;while(reg.test('ab')) &#123; console.log(reg.lastIndex);&#125;// 打印结果为 1，2 test() 本意测试字符串和正则能否匹配上，而不关心是在哪个位置匹配到，所以就没必要加上 g 标志。 RegExp.prototype.exec(str) 使用正则表达式对字符串进行搜索，并将更新全局 RegExp 对象的属性以反映匹配结果 如果没有匹配的文本则返回 null，否则返回一个结果数组，数组有两个属性： index 声明匹配文本地第一个字符的位置 input 存放被检索的字符串 string 第一个元素是与正则表达式相匹配的文本 第二个元素是与正则表达式的第一个子表达式相匹配的文本（如果有的话） 第三个元素是与正则表达式的第二个子表达式相匹配的文本（如果有的话），以此类推… 非全局调用 exec() ，返回数组123456789101112131415var reg = /\\d(\\w)\\d/;var str = '1a2b3c4d5e';var ret = reg.exec(str);console.log(reg.lastIndex); // 0 非全局下，lastIndex 不生效，在此处无意义console.log(ret.index); // 0 匹配结果（1a2）的第一个字符在被检索的字符串(1a2b3c4d5e)中的位置console.log(ret.input); // 1a2b3c4d5econsole.log(ret.toString()); // 1a2,a 全局调用 exec() 时，可以通过循环可以把每次匹配到的结果都拿到12345678var reg = /\\d(\\w)(\\w)\\d/g;var str = '$1az2bb3cy4dd5ee';while(ret = reg.exec(str)) &#123; console.log(reg.lastIndex + '\\t' + ret.index + '\\t' + ret.toString()); // 5 1 1az2,a,z // 11 7 3cy4,c,y&#125; 第一次匹配到的字符串是 1az2 ，它在原字符串中的下一个字符的位置为 5 ，且它第一个字符 1 在原字符串的位置为 1，其中第一个子表达式 a，第二个子表达式 z 第二次匹配到的字符串是 3cy4 ，它在原字符串中的下一个字符的位置为 11 ，且它第一个字符 3 在原字符串的位置为 7，其中第一个子表达式 c，第二个子表达式 y 字符串的与正则相关的方法01-String.prototype.replace()replace() 方法的参数可以是一下几种方式： 1. replace( str, str )123'a1b'.replace('1', '2'); // \"a2b\"'a1b1c1'.replace('1', '2'); // \"a2b1c1\" 2. replace( str, reg )1'a1b1c1'.replace(/1/g, '2'); // \"a2b2c2\" 3. replace( str, function )示例：字符串中每个数字都加 1123456'a1b2c3d4e5'.replace(/\\d/g, function ( match, index, origin ) &#123; // 正则表达式没有分组内容 console.log(index); // 1 3 5 7 9 return parseInt(match) + 1;&#125;);// \"a2b3c4d5e6\" 示例：获取 url 中的查询参数123456789101112131415161718// 1. 准备工作：取得查询字符串// 假设当前 URL 为 'http://www.baidu.com?ie=UTF-8&amp;wd=regexp'// 可用如下方法获取查询字符串// var searchStr = location.search.slice(1); // 'ie=UTF-8&amp;wd=regexp'// 2. 利用正则获取查询参数var searchStr = 'ie=UTF-8&amp;wd=regexp';var paraObj = &#123;&#125;;searchStr.replace(/([^=&amp;]+)=([^=&amp;]*)/ig, function ( match, group1, group2, index, origin) &#123; console.log(match + '\\t' + group1 + '\\t' + group2 + '\\t' + index + '\\t' + origin); // ie=UTF-8 ie UTF-8 0 ie=UTF-8&amp;wd=regexp // wd=regexp wd regexp 9 ie=UTF-8&amp;wd=regexp paraObj[group1] = group2&#125;)console.log(paraObj); function 参数含义： 匹配字符串 正则表达式分组内容，没有分组则没有该参数 匹配项在字符串中的 index 原字符串 match group1 group2 index origin 第一次 ie=UTF-8 ie UTF-8 0 ie=UTF-8&amp;wd=regexp 第二次 wd=regexp wd regexp 9 ie=UTF-8&amp;wd=regexp String.prototype.search(reg) search() 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串 方法返回第一个匹配结果 index ，差找不到返回 -1 search() 不执行全局匹配，他将会略全局标志 g ，并且总是从字符串的开始进行检索 12'a1b2c3d4'.search('1');'a1b2c3d4'.search(/1/); 传入的参数不是正则的时候会尝试将其转换为正则 String.prototype.match(reg) match() 检索字符串，以找到一个或多个与正则表达式相匹配的文本 正则是否具有全局标志 g ，对结果影响很大 String.prototype.split(reg)123'a,b,c,d'.split(','); // [\"a\", \"b\", \"c\", \"d\"]'a1b2c3d'.split(/\\d/); // [\"a\", \"b\", \"c\", \"d\"]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wencaizhang.com/blog/categories/JavaScript/"}],"tags":[{"name":"regexp","slug":"regexp","permalink":"http://wencaizhang.com/blog/tags/regexp/"}]},{"title":"chrome 插件集","slug":"tool/awesome.-chrome-extensions","date":"2017-12-29T16:20:53.000Z","updated":"2018-01-09T10:36:52.272Z","comments":true,"path":"2017/12/30/tool/awesome.-chrome-extensions/","link":"","permalink":"http://wencaizhang.com/blog/2017/12/30/tool/awesome.-chrome-extensions/","excerpt":"","text":"写在前面chrome 插件离线安装方法（chrome 插件通常以 crx 格式保存）： chrome 中打开 chrome://extensions/ 页面 把后缀为 crx 的插件安装文件拖拽到第一步打开的页面中 浏览器弹出确认安装的提示框，点击“添加扩展程序”即可 下面的插件都在百度云盘做了备份，网盘地址：https://pan.baidu.com/s/1gfCjRTD 插件介绍谷歌访问助手 - 访问谷歌 免费，简单 坏处：需要设置hao123为主页 cVim - 使Chrome浏览器支持Vim的快捷键 支持 vim 快捷键，解放鼠标 preview: JSONView - web开发 JSON 数据格式化和高亮插件 在做开发的时候，经常需要从服务器拿数据，一般返回数据都会用 json 来封装。由于一些原因，从服务器端取得的json数据，往往是经过unicode编码，没有格式化的数据，很难阅读。JSONView 正是应用与这个场景，它可以将json数据进行转码和格式化，以一种清晰的形式展示给大家 preview: Octotree - 你的 GitHub 文档库 装了这款插件之后，可以在 GitHub 项目页面的左侧看到相应项目的树状结构图，对于项目管理以及具体的文件跳转来说非常方便。 一键下载文件：GitHub 可以让你很方便的以 .zip 格式下载所有文件，但如果只需要下载一个文件，非常麻烦。使用 Octotree 之后，点击页面左侧项目的树状结构图中对应文件的图标即可下载。 preview: Page Ruler ：你的网页标尺 屏幕尺子插件，非常精确地测量出当前页面某个元素或者是整个页面的大小尺寸 preview: Awesome Autocomplete for GitHub ：属于 GitHub 的 「Alfred」 能够让你在不离开当前项目窗口的前提下，弹窗显示出你的搜索结果，非常方便 preview: Postman - 强大的 API &amp; HTTP 请求调试工具 官方网址：https://www.getpostman.com/ 不仅可以调试简单的 CSS、HTML、脚本等简单的网页基本信息，它还可以发送几乎所有类型的 HTTP 请求，Postman 在发送网络 HTTP 请求方面可以说是 Chrome 插件类产品中的代表产品之一 Infinity 新标签页 Chrome 新标签页应用，重绘了几百个图标，支持自定义搜索，集成天气，带有备忘与 Todo，还可以每日更换壁纸。 如果你已经厌倦了日复一日的默认新标签页，那就试一试 Infinity 吧！ 掘金 - 为设计师、程序员、产品经理每日发现优质内容 聚合了国内外优质的互联网站点内容，在节省你的筛选成本的同时，帮你发现好内容。 Proxy SwitchySharp - 轻松快捷地管理和切换多个代理设置 适用于需要经常切换网络代理的场景 windows 平台蛋疼的代理切换方式谁用谁知道~~~ WEB前端助手(FeHelper) 官方网站：WEB前端助手 前端开发，你值得拥有！~ 广告终结者 谁用谁知道，自从用了广告终结者，妈妈再也不用担心我看到广告了 猎豹翻译 英语学习药不能停！ 翻译类插件多如繁星，选择哪一款就看个人爱好了 preview: 为知笔记网页剪辑器 适合为知笔记用户 可以很方便的把网页上有价值的内容保存到自己的笔记中 新同文堂 - 网页简繁转换工具 浏览一些繁体中文网站时（如鳥哥的 Linux 私房菜）时还是很好用的 chrono 下载管理器 安装之后在浏览器的右上方可以看到其标记按钮，用户可以点击选择开始、暂停、取消等基础操作。还可以自行进行下载任务的添加，而且点击下载任务还会有对应的下载详情弹出，就像桌面上的下载软件一样。另外用户可以自行设置下载的时间顺序，甚至可以将 Chrome 默认只能同时下载 6 个文件的限制提升到 20 个 preview: Listen 1 - 同时搜索并播放来自「网易云音乐，虾米，QQ音乐」的歌曲 Listen 1，整合三大音乐平台的 Chrome 扩展 | App+1 preview:","categories":[{"name":"tool","slug":"tool","permalink":"http://wencaizhang.com/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"http://wencaizhang.com/blog/tags/tool/"}]},{"title":"Win下必备神器之Cmder","slug":"tool/awesome-windows-software-cmder","date":"2017-12-23T05:07:23.000Z","updated":"2018-01-09T10:36:52.271Z","comments":true,"path":"2017/12/23/tool/awesome-windows-software-cmder/","link":"","permalink":"http://wencaizhang.com/blog/2017/12/23/tool/awesome-windows-software-cmder/","excerpt":"","text":"前言对于使用 windows 系统的，需要经常和命令行打交道的童鞋，强烈推荐一个工具：Cmder（Cmder官网: http://cmder.net/） 因为好用，所以必备 本该介绍 Cmder 是什么，如何安装，如何使用……，但是已经有前辈对此进行了详细介绍： Win下必备神器之Cmder 介绍好用工具：Cmder ( 具有Linux 温度的Windows 命令提示字元工具 ) 因此，本篇属于 Cmder 进阶篇，适合已经对 Cmder 有所了解的童鞋阅读，如果不知 Cmder 为何物，推荐先行阅读上面文章 Cmder 如何好用设置默认启动目录连接服务器因为 Cmder 支持 ssh 命令，因此可以直接连接服务器，命令为：ssh 用户名@ip，例如：1ssh root@10.2.5.187 定义 alias 每次连接服务器都需要输入一长串命令，简直不能忍。好在 Cmder 提供了定义 alias 的功能。配置文件是 cmder\\config\\user-aliases.cmd，打开之后会发现，Cmder 已经默认定义了一些 alias。 123456789e.=explorer .gl=git log --oneline --all --graph --decorate $*ls=ls --show-control-chars -F --color $*pwd=cdclear=clshistory=cat \"%CMDER_ROOT%\\config\\.history\"unalias=alias /d $1vi=vim $*cmderr=cd /d \"%CMDER_ROOT%\" 先解释默认定义的这些 alias 的作用 e. : 用资源管理器打开 Cmder 当前所在路径 gl : 使用 git 进行代码管理的童鞋应该不陌生，git log 加上一些参数 ls : 列出当前目录下的文件和目录 pwd : 打印当前目录的完整路径名 clear : 清除屏幕 history : 显示历史命令 unalias : 这个，谁知道能告诉我一声么。。。 vi : 打开 vim 编辑器 cmderr : 切换到 Cmder.exe 所在的目录下 一键切换到指定目录 1tofe=cd /d D:/www/front-end/ 一键连接服务器 12totest=ssh root@10.2.5.187todev=ssh root@10.2.5.188 更多 alias 的可自由发挥~ 各种主题more最后 过一个平凡无趣的人生实在太容易了，你可以不读书，不冒险，不运动，不写作，不外出，不折腾……但是，人生最后悔的事情就是：我本可以。——陈素封。","categories":[{"name":"tool","slug":"tool","permalink":"http://wencaizhang.com/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"http://wencaizhang.com/blog/tags/tool/"}]},{"title":"切换浏览器 tab 标签时动态设置网页 title","slug":"js/toggle-title-on-focus-and-blur","date":"2017-12-22T13:50:23.000Z","updated":"2018-01-13T04:54:14.168Z","comments":true,"path":"2017/12/22/js/toggle-title-on-focus-and-blur/","link":"","permalink":"http://wencaizhang.com/blog/2017/12/22/js/toggle-title-on-focus-and-blur/","excerpt":"","text":"效果在饿了么官网看到一个网页效果，在饿了么网页和其他标签页之间相互切换时，饿了么网页的 title，发生了变化。 饿了么官网: https://www.ele.me/home/ 效果如下： 代码实现预备知识 visibilitychange 事件，会在浏览器标签页被隐藏或显示的时候会触发 document.hidden ，只读属性，返回一个布尔值标识当前页面是否隐藏 document.visibilityState，只读属性，返回 document 的可见性，有 4 个值： visible : 此时页面内容至少是部分可见。 即此页面在前景标签页中，并且窗口没有最小化 hidden : 此时页面对用户不可见。即文档处于背景标签页或者窗口处于最小化状态，或者操作系统正处于锁屏状态 prerender : 页面此时正在渲染中， 因此是不可见的. 文档只能从此状态开始，永远不能从其他值变为此状态 unloaded : 页面从内存中卸载清除 具体代码 使用 document.hidden 属性 12345678910var titleFocus = '饿了么';var titleBlur = '记得回来哦';function toggleTitleHandler(bool) &#123; document.title = bool ? titleBlur : titleFocus;&#125;document.addEventListener(\"visibilitychange\", function () &#123; toggleTitleHandler(document.hidden);&#125;, false); 使用 document.visibilityState 属性 12345678910var titleFocus = '饿了么';var titleBlur = '记得回来哦';function toggleTitleHandler(visibilityState) &#123; document.title = visibilityState === 'hidden' ? titleBlur : titleFocus;&#125;document.addEventListener(\"visibilitychange\", function () &#123; toggleTitleHandler(document.visibilityState);&#125;, false); 其他 此 API 存在兼容性问题，支持 IE10+ 推荐阅读： Page Visibility(页面可见性) API介绍、微拓展 - 张鑫旭（PS：此处献上我的膝盖） 最后，细心的同学可能会发现，本站也是有此效果的哦~","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wencaizhang.com/blog/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wencaizhang.com/blog/tags/JavaScript/"}]},{"title":"Git 基本概念","slug":"git/git-basic-usege","date":"2017-12-21T05:08:23.000Z","updated":"2018-01-13T04:54:14.167Z","comments":true,"path":"2017/12/21/git/git-basic-usege/","link":"","permalink":"http://wencaizhang.com/blog/2017/12/21/git/git-basic-usege/","excerpt":"","text":"git-basic-usege基本概念4 个区使用 Git 进行版本管理，不免会遇到几个概念：工作区、暂存区、本地仓库以及远程仓库。 工作目录：很好理解，就是需要对其进行版本管理的文件目录，也就是日常写代码的目录。 远程仓库：如果想要分享你的代码或者与其他开发人员合作，那么就需要将数据放到一台其他开发人员能够连接的服务器上。这台服务器充当代码中转站的角色，这台服务器也有一个和你本地相同的代码库。每当完成一个功能，把最新的代码推送到这个服务器的代码库，别人就通过这台服务器的代码库获取最新的代码。那么这台服务器的代码库就叫做远程仓库。 本地仓库：Git 是分布式版本控制系统，每个人电脑上都有一个完整的代码仓库。相对于远程仓库来说，自己工作用的电脑上面的代码仓库就是本地仓库。为了让远程仓库和本地仓库保持同步，就需要在本地仓库中更新和推送代码。 暂存区：工作的时候，代码进行了修改，文件发生变动，工作结束的时候，把修改的文件提交到版本库中。这时候就需要先把需要提交的文件保存到暂存区，最后把暂存区的文件提交到代码库中。 希望只提交其中的部分文件 代码提交应该是一项需要慎重的工作，在提交代码之前 工作流程于是，基本的 Git 工作流程如下： 在工作目录中修改某些文件 把修改的文件保存到暂存区域。 将保存在暂存区域的文件提交到本地仓库 把本地仓库更新到远程仓库 文件状态相应的，在每个步骤中的文件也就处于不同的状态： 未修改的文件的状态为 “未修改” 在工作目录中，已修改的文件状态为 “已修改” 把修改的文件保存到暂存区，此时文件状态由 “已修改” 变为 “已暂存” 将保存在暂存区域的文件提交到本地仓库，此时文件状态由 “已暂存” 变为 “已提交” 把本地仓库更新到远程仓库，此时文件状态由 “已提交” 变为 “已推送” 基本使用假设现在有一个 git 仓库 git-learn，git 地址是：https://github.com/wencaizhang/git-learn.git，现在需要在这个仓库中工作。 1. 获取代码 1git clone https://github.com/wencaizhang/git-learn.git 如图所示，仓库中目前只有一个 README.md 文件。 2. 修改 README.md 文件，查看仓库状态 使用 git status 可以查看仓库状态 3. 查看修改内容 提交代码应该是一个严谨的工作，因此提交之前最好能确认本次提交的内容。使用 git diff &lt;filename&gt; 可以查看文件的改动情况 - 表示删除，+ 表示增加，因此，此文件删除了一行，同时增加了一行 4. 撤销修改 此时，如果因为某种原因，希望此文件还原到一开始的状态（即撤销修改的内容），可以使用 git checkout &lt;filename&gt; 命令 5. 保存到暂存区域 如果不打算撤销，而是接着往下进行提交工作，那么就可以使用 git add &lt;filename&gt; 命令可以把修改的文件保存到暂存区 6. 查看暂存区内容 在整个工作流程中，是随时都可查看修改内容的，当文件保存到暂存区之后，可以使用 git diff --staged &lt;filename&gt; 命令查看（和修改区查看相比，多一个参数 --staged） 7. 撤销暂存 不巧的是，在上一步查看修改内容之后，发现之前的修改有所不妥，不想继续往下提交了，希望将此文件还原到一开始的状态（即撤销修改的内容）。 这时候可以使用 git reset &lt;filename&gt; 命令将其从暂存区撤回，然后再使用 git checkout &lt;filename&gt; 命令撤销其内容修改 8. 提交到本地仓库 如果查看了暂存区的文件确认无误，就可以把文件提交到本地仓库了。此时会将暂存区的所有文件全部提交，命令是：git commit -m &quot;提交的描述信息&quot; wait a moment，这里提示设置邮箱和用户名（如果安装 git 之后没有设置邮箱和用户名才会有这个提示） 按照提示进行设置邮箱和用户民，然后进行提交：git commit -m &quot;add a line&quot; 9. 提交到本地仓库后查看提交记录 通过命令 git log ，可以查看每次提交时，提交人的信息，提交时间，提交的描述信息和提交版本号","categories":[{"name":"Git","slug":"Git","permalink":"http://wencaizhang.com/blog/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://wencaizhang.com/blog/tags/Git/"}]},{"title":"Gulp 调试小技巧","slug":"gulp-debug","date":"2017-11-28T13:30:53.000Z","updated":"2018-01-09T10:36:52.264Z","comments":true,"path":"2017/11/28/gulp-debug/","link":"","permalink":"http://wencaizhang.com/blog/2017/11/28/gulp-debug/","excerpt":"编写 gulp 任务时，经常会遇到错误的情况，导致任务执行过程被中断，可以通过事件监听的方式打印错误，并让任务继续往下执行。","text":"编写 gulp 任务时，经常会遇到错误的情况，导致任务执行过程被中断，可以通过事件监听的方式打印错误，并让任务继续往下执行。 基础版主要的思路是通过事件监听把错误打印出来，然后定位错误。 这是部分代码：123.pipe(uglify().on('error', function (e) &#123; console.log(e)&#125;)) 升级版其实就是稍微简单封装一下。 12345678910111213function createErrorHandler(name) &#123; return function (err) &#123; console.error('Error from ' + name + ' in compress task', err.toString()); &#125;;&#125;gulp.task('minify_js', function () &#123; var uglify = require('gulp-uglify'); return gulp.src('./build/**/*.js') .pipe(uglify().on('error', createErrorHandler('uglify'))) .pipe(gulp.dest('build')) .pipe($.size(&#123; title: 'minify_js' &#125;));&#125;)","categories":[{"name":"Gulp","slug":"Gulp","permalink":"http://wencaizhang.com/blog/categories/Gulp/"}],"tags":[{"name":"Gulp","slug":"Gulp","permalink":"http://wencaizhang.com/blog/tags/Gulp/"}]},{"title":"Ubuntu 安装 LAMP 环境","slug":"apt-get-install-LAMP","date":"2017-11-27T13:22:53.000Z","updated":"2018-01-09T10:36:52.260Z","comments":true,"path":"2017/11/27/apt-get-install-LAMP/","link":"","permalink":"http://wencaizhang.com/blog/2017/11/27/apt-get-install-LAMP/","excerpt":"[toc] 安装开发环境亦或部署环境，向来不是一件容易的事情。","text":"[toc] 安装开发环境亦或部署环境，向来不是一件容易的事情。 写在前面 安装顺序，一定是先安装 Apache，后安装 php，因为 php 安装完成之后，会自动修改 Apache 的配置文件 关于 Apache 配置文件，有的地方叫 httpd.conf ，其实就是 apache2.conf mysql 安装 安装命令： 123apt-get install mysql-serverapt-get install mysql-client apt-get install libmysqlclient-dev 安装过程中，会提示为 root 用户设置密码 安装完成之后： 连接 mysql：mysql -u roo t -p 退出 mysql：exit apache 安装 安装命令 1apt-get install apache2 安装完成之后，apache2 的默认主目录：/var/www/apache2 的操作命令（启动 Apache 之后，可以在浏览器中打开 localhost 地址查看 Apache 的默认页面）： 启动：/etc/init.d/apache2 start 重启：/etc/init.d/apache2 restart 关闭：/etc/init.d/apache2 stop php 安装 安装命令 1apt-get install php 安装完成之后查看版本信息：php -v","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://wencaizhang.com/blog/tags/Linux/"},{"name":"部署环境","slug":"部署环境","permalink":"http://wencaizhang.com/blog/tags/部署环境/"}]},{"title":"Linux Tips","slug":"Linux-tips","date":"2017-11-26T13:20:53.000Z","updated":"2018-01-09T10:36:52.260Z","comments":true,"path":"2017/11/26/Linux-tips/","link":"","permalink":"http://wencaizhang.com/blog/2017/11/26/Linux-tips/","excerpt":"","text":"修改普通用户对目录的读写权限普通用户是没有文件的读写权限的，需要每次都临时获取 root 权限，但这样比较麻烦。方便的做法是，修改/var/www目录的读写权限（777是linux中的最高权限，表示可读，可写，可执行）1sudo chmod 777 /var/www 设置别名 alias编辑配置文件 vim /etc/profile，在文件中添加配置代码，例如：12alias tofe=\"cd /var/www/rmp/spms/front-end/\"alias gs=\"git status\" 设置环境变量","categories":[{"name":"Linux","slug":"Linux","permalink":"http://wencaizhang.com/blog/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://wencaizhang.com/blog/tags/Linux/"}]},{"title":"GET 和 POST 的区别","slug":"js/the-difference-of-get-and-post-method","date":"2017-11-25T15:31:23.000Z","updated":"2018-01-09T10:36:52.266Z","comments":true,"path":"2017/11/25/js/the-difference-of-get-and-post-method/","link":"","permalink":"http://wencaizhang.com/blog/2017/11/25/js/the-difference-of-get-and-post-method/","excerpt":"","text":"从表象上看： GET 参数通过 URL 传递，POST 放在 Request body 中。 GET 产生的 URL 地址可以被记录到浏览器历史中，而 POST 不可以。 GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。 GET 请求在URL中传送的参数是有长度限制的，而 POST 没有。 底层来看：无区别 解释如下： 给 GET 加上 request body，给 POST 带上 url 参数，技术上是完全行的通的 为了给不同的区别不同类型的请求，才定义了 GET、POST、PUT、DELETE，依次对应 查、改、增、删 业界不成文的规定是，（大多数）浏览器通常都会限制 url 长度在 2K 个字节，而（大多数）服务器最多处理 64K 大小的 url。超过的部分，恕不处理。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wencaizhang.com/blog/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wencaizhang.com/blog/tags/JavaScript/"}]},{"title":"trim 方法","slug":"js/trim 方法","date":"2017-11-25T13:31:23.000Z","updated":"2018-01-09T10:36:52.265Z","comments":true,"path":"2017/11/25/js/trim 方法/","link":"","permalink":"http://wencaizhang.com/blog/2017/11/25/js/trim 方法/","excerpt":"前言 trim() 方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR）。 删除字符串两端的空白字符可以说是非常常见的需求","text":"前言 trim() 方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR）。 删除字符串两端的空白字符可以说是非常常见的需求我通常用的是 jQuery 提供的 $.trim() 方法，但其实原生 JavaScript 已经提供了 trim() 方法，IE9 以上浏览器已经支持此方法，而且 MDN 文档 也已经提供了兼容旧环境的方法。 so，以后并不一定非要依赖第三方库，完全可以使用原生 tirm() 方法，或者自定义此方法的兼容写法。 通过正则简单实现：123456789101112131415if(!String.prototype.trim) &#123; String.prototype.trim = function () &#123; return this.replace(/^\\s+|\\s+$/g,''); &#125;;&#125;if(!String.prototype.trimLeft) &#123; String.prototype.trimLeft = function () &#123; return this.replace(/^\\s+/,''); &#125;;&#125;if(!String.prototype.trimRight) &#123; String.prototype.trimRight = function () &#123; return this.replace(/\\s+$/,''); &#125;;&#125; 用到的正则： \\s 匹配任何空白字符 + 匹配至少 1 个元字符 ^ 字符串必须以指定的字符开始 $ 字符串必须以指定的字符结束 | 或者 g 全局匹配 more： 更多的实现方式参考：JavaScript trim函数大赏 - 司徒正美 MDN 文档：String.prototype.trim() - MDN","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wencaizhang.com/blog/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wencaizhang.com/blog/tags/JavaScript/"}]},{"title":"好用工具集合","slug":"tool/awesome-tools","date":"2017-11-24T12:20:53.000Z","updated":"2017-12-30T02:20:33.000Z","comments":true,"path":"2017/11/24/tool/awesome-tools/","link":"","permalink":"http://wencaizhang.com/blog/2017/11/24/tool/awesome-tools/","excerpt":"工欲善其事必先利其器轻功不代表武功，但是速度，决定了你和我的距离","text":"工欲善其事必先利其器轻功不代表武功，但是速度，决定了你和我的距离 qimage-win - windows 版本 markdown 一键贴图工具 地址：https://github.com/jiwenxing/qiniu-image-tool-win/releases 简介：windows版本markdown一键贴图工具，支持本地文件、截图、网络图片一键上传七牛云并返回图片引用，让markdown中贴图变成一种享受。 preview： cmder - 程序员的命令行神器（windows 平台） 地址：http://cmder.net/ 简介：windows 平台最好用的命令行 可代替 cmd 和 powershell 自带 Git 支持 ssh 协议，可作为虚拟终端登录服务器 支持部分 Linux 命令 preview： clover - 为您的 Windows Explorer 插上翅膀！ 地址：http://cn.ejie.me/ 简介：Clover 是 Windows Explorer 资源管理器的一个扩展，为其增加类似谷歌 Chrome 浏览器的多标签页功能。 preview： everything - 速度最快的的文件搜索工具 地址：http://www.voidtools.com/ 简介：Locate files and folders by name instantly. preview： FastStone Capture 地址：https://faststone-capture.en.softonic.com/ 简介：Image viewer, editor and screen capture preview： autohotkey - win 下效率神器 地址：https://autohotkey.com/ 简介：Powerful. Easy to learn. The ultimate automation scripting language for Windows. BaiduPanDownloadWinform - 百度网盘不限速下载工具 地址：https://github.com/Accelerider/BaiduPanDownloadWinform/releases 简介：百度网盘不限速下载工具 preview： TeamViewer - 远程支持、远程访问、在线协作和会议 地址：https://www.teamviewer.com/zhCN/ 简介：远程桌面控制，个人免费。 如果您回到家后想连接控制在学校或公司里自己的电脑，TeamViewer无疑就是最佳的解决方案 preview： Snipaste - 开发了三年的截图工具，但不只是截图 地址: https://zh.snipaste.com/download.html 简介: Snipaste，顾名思义， Snip + Paste，截图 + 贴图。使用参考：开发了三年的截图工具，但不只是截图 preview： Listary - Windows 文件浏览增强工具 地址: http://www.listary.com/ 简介: 笨拙的文件管理系统是否减慢了你的工作流程？那就是用 Listary 吧！ preview： 未完待续……","categories":[{"name":"tool","slug":"tool","permalink":"http://wencaizhang.com/blog/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"http://wencaizhang.com/blog/tags/tool/"}]},{"title":"React 点击事件为什么没有被触发？","slug":"react-event","date":"2017-11-19T12:20:53.000Z","updated":"2018-01-09T10:36:52.269Z","comments":true,"path":"2017/11/19/react-event/","link":"","permalink":"http://wencaizhang.com/blog/2017/11/19/react-event/","excerpt":"点击事件可以说是最常用的事件了，但在 React 中有时候事件却没有触发。Why?","text":"点击事件可以说是最常用的事件了，但在 React 中有时候事件却没有触发。Why? 问题描述关键代码如下所示，Title 是一个标题组件，我希望在点击此组件时，执行 handleClick 方法。 但实际上，点击标题时 handleClick 方法并没有被执行。Why?12345678910111213class Container extends Component &#123; handleClick() &#123; console.log('click on container') &#125; render() &#123; return ( &lt;div className=\"container\"&gt; &lt;Title onClick=&#123; this.handleClick.bind(this) &#125;/&gt; &lt;/div&gt; ); &#125;&#125; 原因Title 是 react 组件，并不是一个真实的DOM元素，它不存在点击事件，因为它不是最终渲染的页面的元素。 所有的事件处理函数都必须要绑定到真实的 DOM 上。传给组件，组件只会认为它是个 props。 解决办法有两种 如果 Title 是自定义组件，可以修改组件内部，监听点击事件，通过 props 执行 handleClick 方法，代码如下： 123456789class Title extends Component &#123; render() &#123; return ( &lt;div onClick=&#123; this.props.onClick &#125; className=\"title\"&gt; &lt;h1&gt;React&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125; 如果 Title 是第三方组件，可以在 Title 组件外部包裹一层 DOM 元素，在 DOM 元素上监听点击事件。 12345678910111213class Container extends Component &#123; handleClick() &#123; console.log('click on container') &#125; render() &#123; return ( &lt;div className=\"container\"&gt; &lt;div onClick=&#123; this.handleClick.bind(this) &#125;&gt;&lt;/div&gt;&lt;Title/&gt;&lt;/div&gt; &lt;/div&gt; ); &#125;&#125; 最后，文档是个好东西，文档地址","categories":[{"name":"React","slug":"React","permalink":"http://wencaizhang.com/blog/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://wencaizhang.com/blog/tags/React/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://wencaizhang.com/blog/tags/JavaScript/"}]},{"title":"React 中阻止事件冒泡","slug":"react-stop-propagation","date":"2017-11-19T12:20:53.000Z","updated":"2018-01-09T10:36:52.270Z","comments":true,"path":"2017/11/19/react-stop-propagation/","link":"","permalink":"http://wencaizhang.com/blog/2017/11/19/react-stop-propagation/","excerpt":"react 和原生 JavaScript 阻止事件冒泡的方式是否相同？","text":"react 和原生 JavaScript 阻止事件冒泡的方式是否相同？TODO 问题描述1234567???e.preventDefault(); // 方法阻止元素发生默认的行为（例如，当点击提交按钮时阻止对表单的提交）。但不阻止事件的冒泡传播e.stopPropagation() // 阻止事件的冒泡传播，但不阻止其默认行为returne false; // 阻止两者e.preventDefault();e.stopPropagation();e.nativeEvent.stopImmediatePropagation(); 原因解决办法","categories":[{"name":"React","slug":"React","permalink":"http://wencaizhang.com/blog/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://wencaizhang.com/blog/tags/React/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://wencaizhang.com/blog/tags/JavaScript/"}]},{"title":"微代码","slug":"micro-code","date":"2017-11-19T12:20:53.000Z","updated":"2018-01-09T10:36:52.268Z","comments":true,"path":"2017/11/19/micro-code/","link":"","permalink":"http://wencaizhang.com/blog/2017/11/19/micro-code/","excerpt":"常用代码段，样式代码为主。","text":"常用代码段，样式代码为主。 光标形状 小手 cursor: pointer; 等待 cursor: wait; C3属性 禁用 onclick 事件CSS3 pointer-events:none应用举例及扩展 point-events: auto; 网页被选中文字的背景颜色1234::selection &#123; background-color: green; color: pink;&#125; 修改placeholder文本的样式12345input::-webkit-input-placeholder &#123; color: #ccc; letter-spacing: 2px; font-size: 20px;&#125; 文本间距letter-spacing: 2px; 去掉 input 的外边线outline: none; select 的 option 选项文本默认左对齐，通过以下是属性设置居中12345select &#123; text-align: center; /* 单独一个 text-align 没有效果 */ text-align-last: center;&#125; 点击自身以外的地方，关闭弹出层(待定)12345$(\"body\").click(function() &#123; if($(\".ele\"))&#123; $(\".ele\").hide(); &#125;&#125;) 移动端的问题 iOS/安卓默认样式的不同，如select、a链接 font-size 小于 10px 时候，height 等于 line-height 无法将单行文本居中 input 和 fixed定位的冲突 Web移动端Fixed布局的解决方案 图片 长度单位(px/em/rem) 原生组件样式设置问题，如 input主要思路为隐藏原生组件的样式，设置 label 标签的样式 或者是通过定位、不透明度和层级等属性将原生组件和自定义样式的 div 位置重合，做一个样式的障眼法 禁止用户选中文本12345678div &#123; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;&#125; 多余文本显示省略号1234width: 100px; /* 固定宽度 */overflow: hidden;white-space: nowrap;text-overflow: ellipsis; 双伪元素清除浮动12345678.clearfix:after, .clearfix:before &#123; content: \"\"; display: table; clear: both;&#125;.clearfix &#123; zoom: 1;&#125; 伪元素清除浮动1234567891011.clearfix:after &#123; content:\"\"; height: 0; line-height: 0; display: block; visibility:hidden; clear:both;&#125;.clearfix &#123; zoom: 1;/*用来兼容ie浏览器*/&#125;","categories":[{"name":"code","slug":"code","permalink":"http://wencaizhang.com/blog/categories/code/"}],"tags":[{"name":"code","slug":"code","permalink":"http://wencaizhang.com/blog/tags/code/"}]},{"title":"近期用到的 jQuery 方法整理","slug":"js/近期用到的-jQuery-方法整理","date":"2017-05-27T14:22:53.000Z","updated":"2018-01-09T10:36:52.267Z","comments":true,"path":"2017/05/27/js/近期用到的-jQuery-方法整理/","link":"","permalink":"http://wencaizhang.com/blog/2017/05/27/js/近期用到的-jQuery-方法整理/","excerpt":"好久不用 jQuery，已经快忘得差不多了。最近用 jQuery 写了不少页面，趁机总结一下。毕竟，好记性不如烂笔头。","text":"好久不用 jQuery，已经快忘得差不多了。最近用 jQuery 写了不少页面，趁机总结一下。毕竟，好记性不如烂笔头。 一、选择器部分 $(&quot;input[type=&#39;radio&#39;]&quot;) 选择不同 type 的 input $(&quot;input[type=&#39;radio&#39;]:checked&quot;) 选择被选中的 radio 选择父类元素 $selector.parent(&#39;td&#39;) 仅限于直接父类元素 parent $(this).parents(&#39;.content&#39;) 只要是父类元素即可，能向父级多级查找 parents 选择子类元素 $ele.children(&#39;p.tip&#39;); $this.siblings(&#39;.content&#39;).find(&#39;textarea&#39;) 选择兄弟元素 $selector.parent(&#39;td&#39;).siblings(&#39;.title&#39;) 二、插入和删除元素1. 插入 在被选元素的结尾插入内容 $ele.append(&quot;&lt;p class=&#39;tip red&#39;&gt; &amp;nbsp;&amp;nbsp;请选择&lt;/p&gt;&quot;); 在被选元素的开头插入内容 $(&quot;.must&quot;).prepend(&quot;&lt;span class=&#39;red star&#39;&gt;*&amp;nbsp;&lt;/span&gt;&quot;); 在被选元素之前插入内容 $(&#39;.item:eq(2)&#39;).before($(&#39;.milestone&#39;)); 在被选元素之后插入内容 $(&#39;.item:eq(2)&#39;).after($(&#39;.milestone&#39;)); 2. 删除 remove() 删除被选元素（及其子元素），可传入参数（选择器）作为过滤条件 $tip.remove() 或 $(&quot;p&quot;).remove(&quot;.italic&quot;); empty() 删除被选元素的子元素 $tip.empty() 三、设置元素样式四、动画1. animate 动画使用固定值123$dialog.animate(&#123; top: \"60px\"&#125;) 2. animate 动画使用相对值123$dialog.animate(&#123; top: \"-=60px\"&#125;) 3. 判断当前是否有动画尚未执行完毕 如果正在执行动画返回 true $(&quot;.box&quot;).is(&quot;:animated&quot;) 五、获取和设置元素的值 获取文本域的输入的内容 var $val = $this.siblings(&#39;.content&#39;).find(&#39;textarea&#39;).val(); 获取属性值 var id = $(this).parents(&#39;.item&#39;).attr(&#39;id&#39;); 六、其他的一些方法 清空被选中的 radio $(&quot;input[type=&#39;radio&#39;]&quot;).removeAttr(&#39;checked&#39;); 判断 radio 是否被选中 $(this).is(&quot;:checked&quot;) 判断元素是否具有指定的类名 $(this).hasClass(&quot;bad&quot;) jQuery 对象有 length 属性，该属性表示选中的 DOM 元素的个数 if($radiosChecked.length != 2) {} 判断选中元素是否为 display:none 状态 if(!$(this).is(&quot;:hidden&quot;)) {} 序列化表单数据，用于 ajax 提交表单数据 $(&#39;form&#39;).serialize() 输入框失去焦点 $(&#39;input&#39;).blur(function () {});","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wencaizhang.com/blog/categories/JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"http://wencaizhang.com/blog/tags/js/"},{"name":"jQuery","slug":"jQuery","permalink":"http://wencaizhang.com/blog/tags/jQuery/"}]}]}